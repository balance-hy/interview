# 计算机网络与系统面试题

## 网络

![image-20240503094851416](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240503094851416.png)

### 从输入url到页面展示发生了什么

总体来说分为以下几个步骤:

1. 在浏览器中输入指定网页的 URL。
2. 浏览器通过 DNS 协议，获取域名对应的 IP 地址。
3. 浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。
4. 浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。
5. 服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。
6. 浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。
7. 浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。

### Http

![image-20240501154557342](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240501154557342.png)



### Http和Https的比较

**端口号**：HTTP 默认是 80，HTTPS 默认是 443。

**URL 前缀**：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。

**安全性和资源消耗**：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

**SEO（搜索引擎优化）**：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。

****

### Https的底层原理

对称加密，密钥非对称加密（RSA 大素数分解）后传输

### Http1.0、Http1.1

- **连接方式** : 在**HTTP 1.0中，默认的连接是非持久连接**，也就是说每次请求/响应交换后，连接就会被关闭。这意味着如果一个网页上有多个资源需要加载（如图片、CSS、JavaScript等），每个资源都需要建立和关闭一个新的连接，这会导致大量的开销。而在**HTTP 1.1中，引入了持久连接（也称为连接复用或keep-alive）**，默认的连接是持久的，可以在一个连接上进行多次请求/响应交换，从而减少了开销。
- **状态响应码** : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，`100 (Continue)`——在请求大资源前的预热请求，`206 (Partial Content)`——范围请求的标识码，`409 (Conflict)`——请求与当前资源的规定冲突，`410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址。
- **缓存机制** : 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
- **带宽**：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- **Host 头（Host Header）处理** :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。

****

### Http1.1、Http2.0

- **多路复用（Multiplexing）**：HTTP/2.0 在**同一连接上可以同时传输多个请求和响应**（可以看作是 HTTP/1.1 中长链接的升级版本），互不干扰。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接的限制。。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。
- **二进制帧（Binary Frames）**：HTTP/2.0 **使用二进制帧进行数据传输**，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。
- **头部压缩（Header Compression）**：HTTP/1.1 支持`Body`压缩，`Header`不支持压缩。HTTP/2.0 支持对`Header`压缩，使用了专门为`Header`压缩而设计的 HPACK 算法，减少了网络开销。
- **服务器推送（Server Push）**：HTTP/2.0 **支持服务器推送**，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。

****

### Http2.0、Http3.0

> [HTTP发展史，HTTP1.1与HTTP2.0的区别 - 掘金 (juejin.cn)](https://juejin.cn/post/7079936383925616653)

- **传输协议**：**HTTP/2.0是基于TCP协议实现的，HTTP/3.0新增了QUIC（QuickUDPIntermnetConnections）协议来实现可靠的传输，提供与TLS/SSL相当的安全性，具有较低的连接和传输延迟。**你可以将QUIC看作是UDP的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0之前名为HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3最大的改造就是使用了QUIC。
- **连接建立**：HTTP/2.O需要经过经典的TCP三次握手过程（由于安全的HTTPS连接建立还需要TLS握手，共需要大约3个RTT）。由于QUIC协议的特性（TLS1.3，TLS1.3除了支持1个RTT的握手，还支持0个RTT的握手）连接建立仅需0-RTT或者1-RTT。这意味着QUIC在最佳情况下不需要任何的额外往返时间就可以建立新连接。
- **队头阻塞**：HTTP/2.0多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的HTTP请求。由于QUIC协议的特性，HTTP/3.o在一定程度上解决了队头阻塞（Head-of-Lineblocking，简写：HOLblocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。
- **错误恢复**：HTTP/3.0具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而HTTP/2.O则需要依赖于TCP的错误恢复机制。
- **安全性**：HTTP/2.0和HTTP/3.0在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP/2.0使用TLS协议进行加密，而HTTP/3.0基于QUIC协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。

![image-20240502090028382](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240502090028382.png)

------

### WebSocket

WebSocket 是一种**基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。**

WebSocket 协议在 2008 年诞生，2011 年成为国际标准，几乎所有主流较新版本的浏览器都支持该协议。不过，WebSocket 不只能在基于浏览器的应用程序中使用，很多编程语言、框架和服务器都提供了 WebSocket 支持。

**WebSocket 协议本质上是应用层的协议**，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输

WebSocket 和 HTTP 两者**都是基于 TCP 的应用层协议，都可以在网络中传输数据。**

下面是二者的主要区别：

- WebSocket 是一种**双向实时通信协议，而 HTTP 是一种单向通信协议**。并且，HTTP 协议下的通信只能由客户端发起，服务器无法主动通知客户端。
- WebSocket 使用 ws:// 或 wss://（使用 SSL/TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀，HTTP 使用 http:// 或 https:// 作为协议前缀。
- WebSocket 可以支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。
- **WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小**，而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP/2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）。

>WebSocket协议虽然提供了实时双向通信的能力，但也存在一些不足之处：
>
>1. **兼容性问题**：虽然大多数现代浏览器都支持WebSocket，但一些较旧的浏览器或者网络设备可能不支持。此外，一些网络防火墙和代理可能会阻止WebSocket流量。
>2. **缺乏自动重连机制**：WebSocket协议本身并不提供自动重连的机制，如果连接断开，需要由应用程序来处理重连。
>3. **缺乏原生的消息队列和重发机制**：WebSocket只提供了消息的发送和接收能力，但并没有提供消息队列或者消息重发的机制。如果需要这些功能，需要由应用程序来实现。
>4. **缺乏安全控制**：虽然WebSocket支持加密（通过wss://协议），但并没有提供更细粒度的安全控制，如访问控制、身份验证等。这些需要由应用程序来提供。
>5. **不支持广播和多播**：WebSocket**只支持点对点的通信，不支持广播和多播。**如果需要这些功能，需要由服务器来实现。
>6. **资源消耗**：**每个WebSocket连接都需要一个TCP连接，如果有大量的并发连接，可能会消耗大量的服务器资源。**

****

### Tcp有状态为什么Http无状态

TCP（Transmission Control Protocol，传输控制协议）是一种有状态的协议，**它在建立连接时会进行三次握手，然后在数据传输过程中，会对每个发送的数据包进行确认，如果有数据包丢失，TCP会进行重传，直到所有数据包都被确认接收。这就是所谓的"有状态"，**因为TCP需要维护连接的状态信息，如发送和接收的数据包序号、窗口大小等。

而HTTP（HyperText Transfer Protocol，超文本传输协议）是一种无状态的协议。**"无状态"是指HTTP协议对于事务处理没有记忆能力，服务器不会记住用户的信息**。也就是说，当客户端发送请求给服务器，服务器处理完请求并发送响应后，服务器不会保留任何关于这次请求的信息。如果客户端再次发送请求，服务器会把这个请求当作一个全新的请求来处理。

HTTP之所以设计为无状态，是为了简化服务器的设计，使其能够更好地处理大量的并发请求，提高服务器的性能和可伸缩性。

但是，HTTP的无状态性也带来了一些问题，比如无法直接实现用户的登录状态跟踪。为了解决这个问题，Web应用通常会使用Cookie或Session等技术来维护用户的状态。

****

### Tcp三次握手

<img src="https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240502095726343.png" alt="image-20240502095726343" style="zoom:67%;" />

建立一个 TCP 连接需要“三次握手”，缺一不可：

- **一次握手**:客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 **SYN_SEND** 状态，等待服务器的确认；
- **二次握手**:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 **SYN_RECV** 状态
- **三次握手**:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务器端都进入**ESTABLISHED** 状态，完成 TCP 三次握手。

当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！

------

为什么是三次，而不是二次或者四次

这个问题在谢希仁版《计算机网络》里说了。

三次是保证双方互相明确对方能收能发的最低值。

**理论上讲不论握手多少次都不能确认一条信道是“可靠”的，但通过3次握手可以至少确认它是“可用”的，再往上加握手次数不过是提高“它是可用的”这个结论的可信程度。**

****

### Tcp四次挥手

<img src="https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240502100703635.png" alt="image-20240502100703635" style="zoom:67%;" />

断开一个 TCP 连接则需要“四次挥手”，缺一不可：

1. **第一次挥手**：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 **FIN-WAIT-1** 状态。
2. **第二次挥手**：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后服务端进入 **CLOSE-WAIT** 状态，客户端进入 **FIN-WAIT-2** 状态。
3. **第三次挥手**：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 **LAST-ACK** 状态。
4. **第四次挥手**：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入**TIME-WAIT**状态，**服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了**。

*只要四次挥手没有结束，客户端和服务端就可以继续传输数据！*

------

> 为什么要四次挥手

**TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。**当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

举个例子：A 和 B 打电话，通话即将结束后。

1. **第一次挥手**：A 说“我没啥要说的了”
2. **第二次挥手**：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话
3. **第三次挥手**：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”
4. **第四次挥手**：A 回答“知道了”，这样通话才算结束

------

> 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手

因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。

****

> 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样

客户端没有收到 ACK 确认，会重新发送 FIN 请求。

****

> 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？

第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。

****

### Tcp为什么能保证传输的可靠性

**基于数据块传输**：应用**数据被分割成 TCP 认为最适合发送的数据块**，再传输给网络层，数据块被称为报文段或段。

**对失序数据包重新排序以及去重**：**TCP 为了保证不发生丢包，就给每个包一个序列号**，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。

**校验和** : **TCP 将保持它首部和数据的检验和**。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

**重传机制** : 在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。TCP 重传机制主要有：基于计时器的重传（也就是超时重传）、快速重传（基于接收端的反馈信息来引发重传）、SACK（在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了）、D-SACK（重复 SACK，在 SACK 的基础上，额外携带信息，告知发送方有哪些数据包自己重复接收了）。关于重传机制的详细介绍，可以查看[详解 TCP 超时与重传机制open in new window](https://zhuanlan.zhihu.com/p/101702312)这篇文章。

****

### TCP和UDP

**是否面向连接**：UDP 在**传送数据之前不需要先建立连接**。而 TCP 提供面向连接的服务，在传送数据之前**必须先建立连接**，数据传送结束后要释放连接。

**是否是可靠传输**：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。

**是否有状态**：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。**而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了**（**这很渣男！**）。

**传输效率**：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。

**传输形式**：TCP 是**面向字节流的，UDP 是面向报文的**。

**首部开销**：TCP **首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。**

**是否提供广播或多播服务**：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；

------

**UDP 一般用于即时通信**，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。

**TCP 用于对传输准确性要求特别高的场景**，比如文件传输、发送和接收邮件、远程登录等等。

****

| 常见协议             | 基于Tcp | 基于Udp |
| -------------------- | ------- | ------- |
| HTTP（3.0前）/HTTPs  | 是      |         |
| FTP                  | 是      |         |
| SMTP/POP3            | 是      |         |
| SSH                  | 是      |         |
|                      |         |         |
| HTTP3.0              |         | 是      |
| DHCP(动态配置IP地址) |         | 是      |
| DNS                  |         | 是      |

